# tr: Translate one char to another
# print a sorted list of folders in your path
echo $PATH | tr ":" "\n" | sort

# cut: Get part of a string
# edit scala files that contain "foo"
vi `find . -name *.scala | xargs egrep "foo" | cut -f1 -d ":"`

# cut: Get everyting beyond ':'
cut -d ":" -f1-

# Search for 'foobar' any file in a local git repository
# using find -print0 xargs -0 takes care of spaces and other chars in filenames
# ingnoring '*.git' reduces noise/duplicates from git
find . -not -iwholename '*.git*' -type f -print0 | xargs -0 egrep foobar 

# Find all files, ignoring '.git' and 'target' folders
find . -type d -name target -prune -o -type d -name .git -prune -o -type f -name "*.scala" -print

# Redirect stderr to 'error.txt'
# stdin:0, stdout:1, stderr:2
foo 2> error.txt
# Redirect stdout and stderr to 'all.txt'
foo &> all.txt
# Redirect stderr to stdout
foo 2>&1

#read contents of lib files (elf format)
readelf -a -W <file>
readelf -d <file> | egrep SONAME # read version if present

#find number of processors
cat /proc/cpuinfo | grep processor | wc -l

#join/combine two files line by line
paste file1.txt file2.txt > join.txt

#join two files based on field equality.
#(-1 2) second field of first file, (-2 1) first field of second file
#files have to be sorted and unique on that field
join file1.txt file2.txt -1 2 -2 1 -t"tab"

#print n'th field
cat foo.txt | awk '{print $6 }â€™

#compute average
awk '{ total += $2; count++ } END { print total/count }' 

#print just the matching part of an expression
egrep -o EXPR file

#reading file line by line
while read p; do echo $p done <fileName

#process / list each file in folder
for f in *.c; do echo "Processing $f file.."; done

#filemon equivalent for mac
sudo fs_usage
